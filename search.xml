<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网页性能管理</title>
      <link href="/2022/011224686.html"/>
      <url>/2022/011224686.html</url>
      
        <content type="html"><![CDATA[<h1 id="网页性能管理"><a href="#网页性能管理" class="headerlink" title="网页性能管理"></a>网页性能管理</h1><h2 id="一、必要性"><a href="#一、必要性" class="headerlink" title="一、必要性"></a>一、<strong>必要性</strong></h2><p> 如果一个网页响应非常缓慢，占用大量的CPU和内存，浏览起来常常有卡顿，页面的动画效果也不流畅。对于用户：会关闭这个页面，改为访问其他网站。所以作为一个开发者，肯定不愿意看到这种情况，必须要提高性能。</p><h3 id="1-目的"><a href="#1-目的" class="headerlink" title="1.目的"></a>1.<strong>目的</strong></h3><p>提高网页性能。</p><h3 id="2-原因"><a href="#2-原因" class="headerlink" title="2.原因"></a>2.<strong>原因</strong></h3><h4 id="网页生成过程-五步-："><a href="#网页生成过程-五步-：" class="headerlink" title="网页生成过程(五步)："></a>网页生成过程(五步)：</h4><ol><li><p>HTML代码转化成DOM</p></li><li><p>CSS代码转化成CSSOM（CSS Object Model）</p></li><li><p>结合DOM和CSSOM，生成一棵渲染树</p></li><li><p>生成布局（layout），即将所有渲染树的所有节点进行平面合成</p></li><li><p>将布局绘制（paint）在屏幕上</p><p>这五步里面，第一步到第三步都非常快，耗时的是第四步和第五步。</p><p>“生成布局”（flow）和”绘制”（paint）这两步，合称为”渲染”（render）  </p><p>网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断重新渲染。</p><p>以下三种情况，会导致网页重新渲染。</p><blockquote><ul><li>修改DOM</li><li>修改样式表</li><li>用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等）</li></ul></blockquote></li></ol><p>重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的<strong>根本原因</strong></p><h3 id="3-方向"><a href="#3-方向" class="headerlink" title="3.方向"></a>3.<strong>方向</strong></h3><p>提高网页性能，就是要降低”重排”和”重绘”的频率和成本，尽量少触发重新渲染。</p><h2 id="二、做法"><a href="#二、做法" class="headerlink" title="二、做法"></a>二、<strong>做法</strong></h2><p>因为DOM变动和样式变动，都会触发重新渲染。而现在浏览器会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。</p><blockquote><pre class=" language-javascript"><code class="language-javascript">div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'blue'</span><span class="token punctuation">;</span>div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>marginTop <span class="token operator">=</span> <span class="token string">'30px'</span><span class="token punctuation">;</span></code></pre></blockquote><p>上面代码中，div元素有两个样式变动，但是浏览器只会触发一次重排和重绘。</p><p>如果写得不好，就会触发两次重排和重绘。</p><blockquote><pre class=" language-javascript"><code class="language-javascript">div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'blue'</span><span class="token punctuation">;</span><span class="token keyword">var</span> margin <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>marginTop<span class="token punctuation">)</span><span class="token punctuation">;</span>div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>marginTop <span class="token operator">=</span> <span class="token punctuation">(</span>margin <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span></code></pre></blockquote><p>上面代码对div元素设置背景色以后，第二行要求浏览器给出该元素的位置，所以浏览器不得不立即重排。</p><p>一般来说，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染。</p><blockquote><ul><li>offsetTop/offsetLeft/offsetWidth/offsetHeight</li><li>scrollTop/scrollLeft/scrollWidth/scrollHeight</li><li>clientTop/clientLeft/clientWidth/clientHeight</li><li>getComputedStyle()</li></ul></blockquote><p>所以，从性能角度考虑，尽量不要把读操作和写操作，放在一个语句里面。</p><blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// bad</span>div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetLeft <span class="token operator">+</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token string">"px"</span><span class="token punctuation">;</span>div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetTop <span class="token operator">+</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token string">"px"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// good</span><span class="token keyword">var</span> left <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetLeft<span class="token punctuation">;</span><span class="token keyword">var</span> top  <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetTop<span class="token punctuation">;</span>div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token string">"px"</span><span class="token punctuation">;</span>div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> top <span class="token operator">+</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token string">"px"</span><span class="token punctuation">;</span></code></pre></blockquote><p>一般的规则是：</p><blockquote><ul><li>样式表越简单，重排和重绘就越快。</li><li>重排和重绘的DOM元素层级越高，成本就越高。</li><li>table元素的重排和重绘成本，要高于div元素</li></ul></blockquote><h2 id="三、方法"><a href="#三、方法" class="headerlink" title="三、方法"></a><strong>三、方法</strong></h2><p>有一些JavaScript方法可以调节重新渲染，大幅提高网页性能。</p><h6 id="window-requestAnimationFrame"><a href="#window-requestAnimationFrame" class="headerlink" title="window.requestAnimationFrame()"></a>window.requestAnimationFrame()</h6><p>window.requestAnimationFrame() 方法。它可以将某些代码放到下一次重新渲染时执行。</p><blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">doubleHeight</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">var</span> currentHeight <span class="token operator">=</span> element<span class="token punctuation">.</span>clientHeight<span class="token punctuation">;</span>element<span class="token punctuation">.</span>style<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token punctuation">(</span>currentHeight <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>elements<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>doubleHeight<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></blockquote><p>上面的代码使用循环操作，将每个元素的高度都增加一倍。可是，每次循环都是，读操作后面跟着一个写操作。这会在短时间内触发大量的重新渲染，显然对于网页性能很不利。</p><p>我们可以使用<code>window.requestAnimationFrame()</code>，让读操作和写操作分离，把所有的写操作放到下一次重新渲染。</p><blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">doubleHeight</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">var</span> currentHeight <span class="token operator">=</span> element<span class="token punctuation">.</span>clientHeight<span class="token punctuation">;</span>window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>element<span class="token punctuation">.</span>style<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token punctuation">(</span>currentHeight <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>elements<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>doubleHeight<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></blockquote><h6 id="window-requestIdleCallback"><a href="#window-requestIdleCallback" class="headerlink" title="window.requestIdleCallback()"></a>window.requestIdleCallback()</h6><p>函数<a href="https://w3c.github.io/requestidlecallback/">window.requestIdleCallback()</a>，也可以用来调节重新渲染。</p><p>它指定只有当一帧的末尾有空闲时间，才会执行回调函数。</p><blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></blockquote><p>上面代码中，只有当前帧的运行时间小于16.66ms时，函数fn才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推。</p><p>它还可以接受第二个参数，表示指定的毫秒数。如果在指定 的这段时间之内，每一帧都没有空闲时间，那么函数fn将会强制执行。</p><blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></blockquote><p>上面的代码表示，函数fn最迟会在5000毫秒之后执行。</p><h2 id="四、技巧"><a href="#四、技巧" class="headerlink" title="四、技巧"></a><strong>四、技巧</strong></h2><p>第一条，DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</p><p>第二条，如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。</p><p>第三条，不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。</p><blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// bad</span><span class="token keyword">var</span> left <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">var</span> top <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token string">"px"</span><span class="token punctuation">;</span>el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top  <span class="token operator">=</span> top  <span class="token operator">+</span> <span class="token string">"px"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// good </span>el<span class="token punctuation">.</span>className <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">" theclassname"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// good</span>el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">"; left: "</span> <span class="token operator">+</span> left <span class="token operator">+</span> <span class="token string">"px; top: "</span> <span class="token operator">+</span> top <span class="token operator">+</span> <span class="token string">"px;"</span><span class="token punctuation">;</span></code></pre></blockquote><p>第四条，尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。</p><p>第五条，先将元素设为 display: none （需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。</p><p>第六条，position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。</p><p>第七条，只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden 的元素只对重排有影响，不影响重绘。</p><p>第八条，使用虚拟DOM的脚本库，比如React等。</p><p>第九条，使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/011216107.html"/>
      <url>/2022/011216107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
