<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>网页性能管理 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="网页性能管理一、必要性 如果一个网页响应非常缓慢，占用大量的CPU和内存，浏览起来常常有卡顿，页面的动画效果也不流畅。对于用户：会关闭这个页面，改为访问其他网站。所以作为一个开发者，肯定不愿意看到这种情况，必须要提高性能。 1.目的提高网页性能。 2.原因网页生成过程(五步)： HTML代码转化成DOM  CSS代码转化成CSSOM（CSS Object Model）  结合DOM和CSSOM，生">
<meta property="og:type" content="article">
<meta property="og:title" content="网页性能管理">
<meta property="og:url" content="http://example.com/2022/01/12/20220112myblog/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="网页性能管理一、必要性 如果一个网页响应非常缓慢，占用大量的CPU和内存，浏览起来常常有卡顿，页面的动画效果也不流畅。对于用户：会关闭这个页面，改为访问其他网站。所以作为一个开发者，肯定不愿意看到这种情况，必须要提高性能。 1.目的提高网页性能。 2.原因网页生成过程(五步)： HTML代码转化成DOM  CSS代码转化成CSSOM（CSS Object Model）  结合DOM和CSSOM，生">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-01-12T03:19:29.000Z">
<meta property="article:modified_time" content="2022-01-12T03:21:04.440Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-20220112myblog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/12/20220112myblog/" class="article-date">
  <time datetime="2022-01-12T03:19:29.000Z" itemprop="datePublished">2022-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      网页性能管理
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="网页性能管理"><a href="#网页性能管理" class="headerlink" title="网页性能管理"></a>网页性能管理</h1><h2 id="一、必要性"><a href="#一、必要性" class="headerlink" title="一、必要性"></a>一、<strong>必要性</strong></h2><p> 如果一个网页响应非常缓慢，占用大量的CPU和内存，浏览起来常常有卡顿，页面的动画效果也不流畅。对于用户：会关闭这个页面，改为访问其他网站。所以作为一个开发者，肯定不愿意看到这种情况，必须要提高性能。</p>
<h3 id="1-目的"><a href="#1-目的" class="headerlink" title="1.目的"></a>1.<strong>目的</strong></h3><p>提高网页性能。</p>
<h3 id="2-原因"><a href="#2-原因" class="headerlink" title="2.原因"></a>2.<strong>原因</strong></h3><h4 id="网页生成过程-五步-："><a href="#网页生成过程-五步-：" class="headerlink" title="网页生成过程(五步)："></a>网页生成过程(五步)：</h4><ol>
<li><p>HTML代码转化成DOM</p>
</li>
<li><p>CSS代码转化成CSSOM（CSS Object Model）</p>
</li>
<li><p>结合DOM和CSSOM，生成一棵渲染树</p>
</li>
<li><p>生成布局（layout），即将所有渲染树的所有节点进行平面合成</p>
</li>
<li><p>将布局绘制（paint）在屏幕上</p>
<p>这五步里面，第一步到第三步都非常快，耗时的是第四步和第五步。</p>
<p>“生成布局”（flow）和”绘制”（paint）这两步，合称为”渲染”（render）  </p>
<p>网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断重新渲染。</p>
<p>以下三种情况，会导致网页重新渲染。</p>
<blockquote>
<ul>
<li>修改DOM</li>
<li>修改样式表</li>
<li>用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等）</li>
</ul>
</blockquote>
</li>
</ol>
<p>重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的<strong>根本原因</strong></p>
<h3 id="3-方向"><a href="#3-方向" class="headerlink" title="3.方向"></a>3.<strong>方向</strong></h3><p>提高网页性能，就是要降低”重排”和”重绘”的频率和成本，尽量少触发重新渲染。</p>
<h2 id="二、做法"><a href="#二、做法" class="headerlink" title="二、做法"></a>二、<strong>做法</strong></h2><p>因为DOM变动和样式变动，都会触发重新渲染。而现在浏览器会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.style.color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">div.style.marginTop = <span class="string">&#x27;30px&#x27;</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，div元素有两个样式变动，但是浏览器只会触发一次重排和重绘。</p>
<p>如果写得不好，就会触发两次重排和重绘。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div.style.color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> margin = <span class="built_in">parseInt</span>(div.style.marginTop);</span><br><span class="line">div.style.marginTop = (margin + <span class="number">10</span>) + <span class="string">&#x27;px&#x27;</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码对div元素设置背景色以后，第二行要求浏览器给出该元素的位置，所以浏览器不得不立即重排。</p>
<p>一般来说，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染。</p>
<blockquote>
<ul>
<li>offsetTop/offsetLeft/offsetWidth/offsetHeight</li>
<li>scrollTop/scrollLeft/scrollWidth/scrollHeight</li>
<li>clientTop/clientLeft/clientWidth/clientHeight</li>
<li>getComputedStyle()</li>
</ul>
</blockquote>
<p>所以，从性能角度考虑，尽量不要把读操作和写操作，放在一个语句里面。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">div.style.left = div.offsetLeft + <span class="number">10</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">div.style.top = div.offsetTop + <span class="number">10</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> left = div.offsetLeft;</span><br><span class="line"><span class="keyword">var</span> top  = div.offsetTop;</span><br><span class="line">div.style.left = left + <span class="number">10</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">div.style.top = top + <span class="number">10</span> + <span class="string">&quot;px&quot;</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>一般的规则是：</p>
<blockquote>
<ul>
<li>样式表越简单，重排和重绘就越快。</li>
<li>重排和重绘的DOM元素层级越高，成本就越高。</li>
<li>table元素的重排和重绘成本，要高于div元素</li>
</ul>
</blockquote>
<h2 id="三、方法"><a href="#三、方法" class="headerlink" title="三、方法"></a><strong>三、方法</strong></h2><p>有一些JavaScript方法可以调节重新渲染，大幅提高网页性能。</p>
<h6 id="window-requestAnimationFrame"><a href="#window-requestAnimationFrame" class="headerlink" title="window.requestAnimationFrame()"></a>window.requestAnimationFrame()</h6><p>window.requestAnimationFrame() 方法。它可以将某些代码放到下一次重新渲染时执行。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleHeight</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> currentHeight = element.clientHeight;</span><br><span class="line">element.style.height = (currentHeight * <span class="number">2</span>) + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">elements.forEach(doubleHeight);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的代码使用循环操作，将每个元素的高度都增加一倍。可是，每次循环都是，读操作后面跟着一个写操作。这会在短时间内触发大量的重新渲染，显然对于网页性能很不利。</p>
<p>我们可以使用<code>window.requestAnimationFrame()</code>，让读操作和写操作分离，把所有的写操作放到下一次重新渲染。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleHeight</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> currentHeight = element.clientHeight;</span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">element.style.height = (currentHeight * <span class="number">2</span>) + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">elements.forEach(doubleHeight);</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="window-requestIdleCallback"><a href="#window-requestIdleCallback" class="headerlink" title="window.requestIdleCallback()"></a>window.requestIdleCallback()</h6><p>函数<a target="_blank" rel="noopener" href="https://w3c.github.io/requestidlecallback/">window.requestIdleCallback()</a>，也可以用来调节重新渲染。</p>
<p>它指定只有当一帧的末尾有空闲时间，才会执行回调函数。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback(fn);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，只有当前帧的运行时间小于16.66ms时，函数fn才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推。</p>
<p>它还可以接受第二个参数，表示指定的毫秒数。如果在指定 的这段时间之内，每一帧都没有空闲时间，那么函数fn将会强制执行。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback(fn, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的代码表示，函数fn最迟会在5000毫秒之后执行。</p>
<h2 id="四、技巧"><a href="#四、技巧" class="headerlink" title="四、技巧"></a><strong>四、技巧</strong></h2><p>第一条，DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</p>
<p>第二条，如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。</p>
<p>第三条，不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> left = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> top = <span class="number">10</span>;</span><br><span class="line">el.style.left = left + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">el.style.top  = top  + <span class="string">&quot;px&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good </span></span><br><span class="line">el.className += <span class="string">&quot; theclassname&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">el.style.cssText += <span class="string">&quot;; left: &quot;</span> + left + <span class="string">&quot;px; top: &quot;</span> + top + <span class="string">&quot;px;&quot;</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>第四条，尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。</p>
<p>第五条，先将元素设为 display: none （需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。</p>
<p>第六条，position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。</p>
<p>第七条，只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden 的元素只对重排有影响，不影响重绘。</p>
<p>第八条，使用虚拟DOM的脚本库，比如React等。</p>
<p>第九条，使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/12/20220112myblog/" data-id="ckyazk7ef0001jsvi7ztt1p83" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/01/12/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/01/12/20220112myblog/">网页性能管理</a>
          </li>
        
          <li>
            <a href="/2022/01/12/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>